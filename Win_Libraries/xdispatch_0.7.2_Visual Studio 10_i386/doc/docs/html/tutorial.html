<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Getting Started</title>
	<link href="search/search.css" rel="stylesheet" type="text/css">
	<link href="styles.css" rel="stylesheet" type="text/css">
		
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="search/search.js"></script>
	<script type="text/javascript">
	  $(document).ready(function() { searchBox.OnSelectItem(0); });
	</script>
</head><body>
<div class="custom_header" style="padding-left: 150px;">XDispatch 0.7.2</div>
<!--
<div id="global_nav">
	<a href="http://opensource.mlba-team.de/xdispatch/news.htm">
		<div class="global_nav_item" style="background-image: URL(nav_news.png);">
		<span>News</span><br/>
		Updates and announcements
		</div>
	</a>
	<a href="http://opensource.mlba-team.de/xdispatch/files">
		<div class="global_nav_item" style="background-image: URL(nav_downloads.png);">
		<span>Downloads</span><br/>
		Obtain binaries and source packages
		</div>
	</a>
	<a href="http://opensource.mlba-team.de/mailman/listinfo/libxdispatch">
		<div class="global_nav_item" style="background-image: URL(nav_mailinglist.png);">
		<span>Mailing List</span><br/>
		Join the discussion
		</div>
	</a>
	<a href="tutorial.html">
		<div class="global_nav_item" style="background-image: URL(nav_tutorial.png);">
		<span>Getting started</span><br/>
		The first steps to using xdispatch
		</div>
	</a>
</div>
-->
<!-- Generated by Doxygen 1.8.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Special&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
<div class="header">
  <div class="headertitle">
<div class="title">Getting Started </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author:</dt><dd>Marius Zwicker / MLBA</dd></dl>
<h2><a class="anchor" id="tut_intro"></a>
Introduction</h2>
<p>This page will give you a short introduction concerning the concepts enforced throughout XDispatch and also help you getting started by first integrating libxdispatch into your project and writing the first lines of code afterwards. libxdispatch aims to provide an environment within which you can write parallelized code using the concepts of Grand Central Dispatch while keeping cross-platfrom compatibility and thus leaves it up to you, which operating systems you intend to target.</p>
<h2><a class="anchor" id="tut_conf"></a>
Configuring your environment</h2>
<p>The quickest way for getting started is obtaining a binary suitable for your development environment by going to the <a href="http://opensource.mlba-team.de/xdispatch/files">download section</a>. There you can find binaries for Linux, Windows and Mac OS X. Download the appropriate archive and install it on your system.</p>
<h3><a class="anchor" id="tut_conf_mac"></a>
Mac OS X</h3>
<p>On Mac OS you will only have to execute the provided package installer. It will automatically copy xdispatch.framework and (if selected) QtDispatch.framework to the '/Library' directory. Afterwards you can use the libraries by including one of the headers</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;dispatch/dispatch.h&gt;</span>
<span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>
</pre></div><p>As with any other framework you will need to link your executable against the framework, so either pass '-framework xdispatch' when invoking gcc or configure your IDE to link against the xdispatch framework.</p>
<dl class="section remark"><dt>Remarks:</dt><dd>As Grand Central Dispatch is an operating system component on Mac OS you will NOT have to link against libdispatch by hand. This will happen completely automatically.</dd></dl>
<h3><a class="anchor" id="tut_conf_win"></a>
Windows</h3>
<p>Extract the archive and copy it to some place on the disk. The provided archives contain three directories: </p>
<ul>
<li>
<em>include</em> - Location of the header files </li>
<li>
<em>lib</em> - Location of the lib files you will have to link against </li>
<li>
<em>bin</em> - Location of the dll files. </li>
</ul>
<p>To use xdispatch, make sure the three directories listed above are listed in the INCLUDE, LIB and PATH (for the bin directory) environment variables. When using Visual Studio you might also want to change the include and linker directories within your project configuration. Afterwards you can use the libraries by including one of the headers</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;dispatch/dispatch.h&gt;</span>
<span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>
</pre></div><p>Configure your project to link against the xdispatch and dispatch libs.</p>
<h3><a class="anchor" id="tut_conf_linux"></a>
Linux</h3>
<p>The recommended way on Linux is to use the provided packages by subscribing the <a href="https://launchpad.net/~mlba-team/+archive/stable">PPA on Launchpad</a>: </p>
<div class="fragment"><pre class="fragment">sudo apt-add-repository ppa:mlba_team/stable
sudo apt-<span class="keyword">get</span> update
sudo apt-<span class="keyword">get</span> install libxdispatch-dev libdispatch-dev
</pre></div><p>Packages for debian and RPM packages for openSUSE &amp; Co will be released in the future.</p>
<p>In the meantime when not using Ubuntu, download the provided binary tarball according to your architecture and extract the headers and libraries to their corresponding places. Afterwards you can use the libraries by including one of the headers</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;dispatch/dispatch.h&gt;</span>
<span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>
</pre></div><p>As with any other shared library you will need to link your executable against them, so either pass '-lxdispatch -ldispatch' when invoking gcc or configure your IDE to link against the xdispatch framework.</p>
<dl class="section remark"><dt>Remarks:</dt><dd>When using clang and lambdas, you will also have to link against the <a href="http://mackyle.github.com/blocksruntime/">BlocksRuntime</a>. It will be installed as a depedency on Ubuntu by default and is included in the tarball for all other Linux distributions. You will have to call clang with the parameters '-lxdispatch -ldispatch -lBlocksRuntime -fblocks'.</dd></dl>
<h2><a class="anchor" id="tut_first"></a>
First Steps</h2>
<p>Using libXDispatch within your source code is pretty straight forward as all you need to do is to include the headers within your source files - that's it.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>
</pre></div><p>All functions are located in the xdispatch namespace. In the following I will demonstrate some use cases occuring when trying to parallelize the code. I will assume that your are either using gcc-4.5+, Visual Studio 2010 or clang as your compiler as enables us to utilize lambdas. For those not being able to use a "modern" compiler, please have a look at <a class="el" href="tutorial.html#tut_first_operations">Parallel code using xdispatch::operations</a>.</p>
<h3><a class="anchor" id="tut_first_lambdas"></a>
Parallel code using lambdas</h3>
<p>The most obvious use case is that you want to move some heavy calculation work off the main thread and into a background worker. Now without using libXDispatch, you'd probably be writing something similar to this:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;pthread.h&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="comment">// declared somewhere else</span>
<span class="keyword">class </span>SomeData {
       <span class="keywordtype">bool</span> finished;
       pthread_mutex_t lock;
 ...
};

<span class="comment">/*</span>
<span class="comment"> The worker function doing all the stuff</span>
<span class="comment"> */</span>
 <span class="keywordtype">void</span>* do_work(<span class="keywordtype">void</span>* dt){
       SomeData* data = (SomeData*)dt;
       
       <span class="comment">// execute the heavy code</span>
       do_calculations(data);
       
       <span class="comment">// notify the main thread we are finished</span>
       pthread_mutex_lock(&amp;data-&gt;lock);
       data-&gt;finished = <span class="keyword">true</span>;
       pthread_mutex_unlock(%data-&gt;lock);
 }
 
<span class="comment">/*</span>
<span class="comment"> This function is getting called</span>
<span class="comment"> from your main thread also powering</span>
<span class="comment"> the user interface</span>
<span class="comment"> */</span>
<span class="keywordtype">void</span> some_function(){

       SomeData* sd = <span class="keyword">new</span> SomeData();
       fill_data(sd);

       pthread_t worker;
       
       
       <span class="keywordflow">if</span>(pthread_create(&amp;worker, NULL, do_work, NULL, (<span class="keywordtype">void</span>*)sd)){
              std::cerr &lt;&lt; <span class="stringliteral">&quot;Failed to create worker thread&quot;</span> &lt;&lt; std::endl;
              <span class="keywordflow">return</span>;
       }
       
       pthread_mutex_lock(&amp;sd-&gt;lock);
       <span class="keywordflow">while</span>(!sd-&gt;finished){
              pthread_mutex_unlock(&amp;sd-&gt;lock);
              
              <span class="comment">// process all events on the main thread</span>
              process_events();
              
              pthread_mutex_lock(&amp;sd-&gt;lock);
       }
       
       <span class="comment">// ok, now the worker has finished, show the results within the gui</span>
       show_calc_results(sd);
       <span class="keyword">delete</span> sd;
}
</pre></div><p>So this is an example using pthreads. When writing for windows as well, we'd probably need to write another version using WindowsThreads or need to use a library such as OpenThreads or boost::threads. When using libXDispatch, we can express this code much more effectively - and still maintain cross platform compatibility:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>

<span class="comment">// declared somewhere else</span>
<span class="keyword">class </span>SomeData {
 ...
};
 
<span class="comment">/*</span>
<span class="comment"> This function is getting called</span>
<span class="comment"> from your main thread also powering</span>
<span class="comment"> the user interface</span>
<span class="comment"> */</span>
<span class="keywordtype">void</span> some_function(){

       SomeData* sd = <span class="keyword">new</span> SomeData();
       fill_data(sd);
       
       <a class="code" href="namespacexdispatch.html#a0084c3cb53bea140e88770b38c1e8489" title="Returns the global queue associated to the given Priority p.">xdispatch::global_queue</a>().<a class="code" href="classxdispatch_1_1queue.html#ad9cb47a2b49d7aa9c2bbffbf1cd35b78" title="Will dispatch the given operation for async execution on the queue and return immediately.">async</a>(${
       
              <span class="comment">// execute the heavy code</span>
              do_calulations(sd);
              
              <span class="comment">// notify the gui that we are finished</span>
              <a class="code" href="namespacexdispatch.html#a6105d87327ac15791ea4e38e1061b0e2" title="Returns the main queue.">xdispatch::main_queue</a>().<a class="code" href="classxdispatch_1_1queue.html#ad9cb47a2b49d7aa9c2bbffbf1cd35b78" title="Will dispatch the given operation for async execution on the queue and return immediately.">async</a>(${
                     show_calc_results(sd);
                     <span class="keyword">delete</span> sd;
              });
       
       });
}
</pre></div><p>There's no need for manual thread creation and so on. Also note, that we can use all variables declared within <em>some_function()</em> within our lambda code <em>${ .. }</em>. It's just as easy when you want to parallelize a loop. Let's assume the following piece of code (Please note this is still a very simple calculation):</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>

<span class="comment">// declared somewhere else</span>
<span class="keyword">class </span>SomeData {
 ...
 std::vector&lt;double&gt; a;
 std::vector&lt;double&gt; b;
 std::vector&lt;double&gt; c;
 std::vector&lt;double&gt; results; 
};

<span class="keywordtype">void</span> do_calculations(SomeData* sd){
       
       <span class="comment">// our output will go in here</span>
       sd-&gt;results = std::vector&lt;double&gt;(sd-&gt;a.size());
       
       <span class="comment">// the calculation - running on one thread only</span>
       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; a.size(); i++){
              sd-&gt;results[i] = 0;
              <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; b.size(); j++){
                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = 0; z &lt; c.size(); z++){
                            sd-&gt;results[i] += std::pow(sd-&gt;b[j], sd-&gt;a[i]) * std::sin(sd-&gt;c[z]);
                     }
              }
       }
}
</pre></div><p>Now to parallelize this piece of code using libXDispatch you can simply write:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>
<span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>

<span class="comment">// declared somewhere else</span>
<span class="keyword">class </span>SomeData {
 ...
 std::vector&lt;double&gt; a;
 std::vector&lt;double&gt; b;
 std::vector&lt;double&gt; c;
 std::vector&lt;double&gt; results; 
};

<span class="keywordtype">void</span> do_calculations(SomeData* sd){
       
       <span class="comment">// our output will go in here</span>
       sd-&gt;results = std::vector&lt;double&gt;(sd-&gt;a.size());
       
       <span class="comment">// the calculation - running on multiple threads</span>
       <a class="code" href="namespacexdispatch.html#a0084c3cb53bea140e88770b38c1e8489" title="Returns the global queue associated to the given Priority p.">xdispatch::global_queue</a>().<a class="code" href="classxdispatch_1_1queue.html#ae9e9a43065539de47ebe675f77ddcd88" title="Applies the given iteration_operation for async execution in this queue and returns immediately...">apply</a>($(<span class="keywordtype">size_t</span> i){
              sd-&gt;results[i] = 0;
              <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; b.size(); j++){
                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = 0; z &lt; c.size(); z++){
                            sd-&gt;results[i] += std::pow(sd-&gt;b[j], sd-&gt;a[i]) * std::sin(sd-&gt;c[z]);
                     }
              }
       }, a.size());
}
</pre></div><p>libXDispatch is also providing mechanisms for making some piece of code perfectly threadsafe. So again assume the following piece of code:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;pthread.h&gt;</span>

<span class="keyword">static</span> pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

<span class="comment">/*</span>
<span class="comment"> So this function is called from several threads</span>
<span class="comment"> */</span>
<span class="keywordtype">void</span> worker(){

       <span class="comment">// some work</span>
       ...
       
       pthread_mutex_lock(&amp;lock);
              <span class="comment">// do some critical work    </span>
              <span class="keywordflow">if</span>(already_done){ <span class="comment">// we might have finished here</span>
                     pthread_mutex_unlock(&amp;lock);
                     <span class="keywordflow">return</span>;
              }
              <span class="comment">// do some other critical work</span>
       pthread_mutex_lock(&amp;lock);
       
       <span class="comment">// some other work</span>
       ...
}
</pre></div><p>We will have to make sure the mutex is cleanly unlocked whenever leaving the critical section. And what happens if an exception is thrown from within that we do not catch? This might result in a deadlock. All this can be easily resolved by using the following expression:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>

<span class="comment">/*</span>
<span class="comment"> So this function is called from several threads</span>
<span class="comment"> */</span>
<span class="keywordtype">void</span> worker(){

       <span class="comment">// some work</span>
       ...
       
       <span class="keyword">synchronized</span> {
              <span class="comment">// do some critical work    </span>
              <span class="keywordflow">if</span>(already_done) <span class="comment">// we might have finished here</span>
                     <span class="keywordflow">return</span>;
              <span class="comment">// do some other critical work</span>
       }
       
       <span class="comment">// some other work</span>
       ...
}
</pre></div><p>No need to handle the locking by yourself, all is done magically - and it is ensured that the lock will be automatically cleared whenever you leave the section marked by the brackets. For further details about this, please see the documentation on the <a class="el" href="classxdispatch_1_1synclock.html" title="Provides an easy locking mechanism used to ensure the threadsafety of a code area.">xdispatch::synclock</a>. Please note that his functionality is available on compilers without lambda support as well.</p>
<h3><a class="anchor" id="tut_first_operations"></a>
Parallel code using xdispatch::operations</h3>
<p>All the examples shown above can also be written without using lambdas. So for example the parallel loop can also be expressed using an <a class="el" href="classxdispatch_1_1iteration__operation.html">xdispatch::iteration_operation</a>:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;cmath&gt;</span>
<span class="preprocessor">#include &lt;xdispatch/dispatch&gt;</span>

<span class="comment">// declared somewhere else</span>
<span class="keyword">class </span>SomeData {
 ...
 std::vector&lt;double&gt; a;
 std::vector&lt;double&gt; b;
 std::vector&lt;double&gt; c;
 std::vector&lt;double&gt; results; 
};

<span class="keyword">class </span>InnerCalculation : <span class="keyword">public</span> <a class="code" href="classxdispatch_1_1iteration__operation.html">xdispatch::iteration_operation</a> {
       
       SomeData* sd;
       
<span class="keyword">public</span>:
       InnerCalculation(SomeData* d) : sd(d) {}
       
       <span class="keywordtype">void</span> <a class="code" href="classxdispatch_1_1iteration__operation.html#abbaf4ad613d4b68811dfb88bca7803f0">operator()</a>(<span class="keywordtype">size_t</span> i){
              sd-&gt;results[i] = 0;
              <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; b.size(); j++){
                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = 0; z &lt; c.size(); z++){
                            sd-&gt;results[i] += std::pow(sd-&gt;b[j], sd-&gt;a[i]) * std::sin(sd-&gt;c[z]);
                     }
              }      
       }

}

<span class="keywordtype">void</span> do_calculations(SomeData* sd){
       
       <span class="comment">// our output will go in here</span>
       sd-&gt;results = std::vector&lt;double&gt;(sd-&gt;a.size());
       
       <span class="comment">// the calculation - running on multiple threads</span>
       <a class="code" href="namespacexdispatch.html#a0084c3cb53bea140e88770b38c1e8489" title="Returns the global queue associated to the given Priority p.">xdispatch::global_queue</a>().<a class="code" href="classxdispatch_1_1queue.html#ae9e9a43065539de47ebe675f77ddcd88" title="Applies the given iteration_operation for async execution in this queue and returns immediately...">apply</a>(<span class="keyword">new</span> InnerCalculation(sd), a.size());
}
</pre></div><p>There is no need to worry about memory leaks - xdispatch will automatically delete the iteration_operation once it has finished execution.</p>
<h2><a class="anchor" id="tut_conc"></a>
Concepts</h2>
<p>The examples above showed only some of the functionality and power of libXDispatch. Of course there also is a plean C interface and Qt integration provided within QtDispatch. For further exploration, we recommend browsing the API documentation and having a look at the various unittests.</p>
<p>There is also a lot more concepts to explore. For example you could create your own queues and not only use the automatically provided global queues. For understanding the idea of serial and concurrent queues and the usage of setting a target for a queue, we recommend to read the document <a href="http://opensource.mlba-team.de/xdispatch/GrandCentral_TB_brief_20090608.pdf">"Apple Technical Brief on Grand Central Dispatch"</a> and have a look at <a href="http://developer.apple.com/library/mac/#documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091">Apple's Concurrency Programming Guide</a> </p>
</div></div><!-- contents -->
<hr size="1"><address style="text-align: right; margin: 15px;"><small>
Generated on Sun Jan 27 2013 20:26:00 for XDispatch by&nbsp;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.0</a><br/>
&copy 2010-2013 MLBA (<a href="http://www.mlba-team.de/impressum.htm">about</a> | <a href="http://www.mlba-team.de/impressum.htm">privacy</a>) All Rights reserved.</small></address>

<!-- Piwik 
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://stats.mlba-team.de/piwik/" : "http://stats.mlba-team.de/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://stats.mlba-team.de/piwik/piwik.php?idsite=1" style="border:0" alt="" /></p></noscript>
<!-- End Piwik Tracking Code -->		 
</body>
</html>
